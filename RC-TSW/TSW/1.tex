\section{Introduzione al World Wide Web}
    Il \textbf{World Wide Web} è un immenso insieme di documenti, testuali e non, interconnessi tramite \textit{hyperlinks}. Da non confondere con \textbf{Internet}, che è invece una rete di computer, si può dire che il Web è un servizio che gira su Internet. Tutti i documenti che formano il Web sono messi a disposizione da dei server, sono generalmente organizzati in siti e possono essere identificati da degli URL.
    
    \vspace{3mm}
    
    Informalmente, si può dire che i tre grandi protagonisti del Web siano gli \textit{URL}, l'\textit{HTTP} e l'\textit{HTML}.
    
    \subsection{Localizzare le risorse}
    
        Partiamo dicendo che ogni risorsa sul Web ha un indirizzo unico nel formato URL, ossia \textbf{Uniform Resource Locator}.
    
        \subsubsection{URI}
        
            Gli URI, \textbf{Uniform Resource Identifier}, sono una generalizzazione degli URL e forniscono un meccanismo semplice ed estendibile per identificare una qualsiasi risorsa, anche non presente su Internet. Con il termine "\textit{risorsa}", in ogni caso, intendiamo una qualunque entità dotata di identità: un documento, un immagine, un servizio, una collezione di differenti risorse.
            
            \vspace{3mm}
            
            Un URI è un concetto generale: non fa riferimento necessariamente a risorse accessibili tramite HTTP o ad entità disponibili in rete; inoltre, è un mapping concettuale ad un'entità: non si riferisce necessariamente ad una particolare versione dell'entità esistente in un dato momento, e tale mapping può rimanere inalterato anche se cambia il contenuto della risorsa stessa. 
            
            \vspace{3mm}
            
            Gli URI rispettano una sintassi standard, semplice e regolare, e i suoi identificatori sono uniformi: l'uniformità ha diversi vantaggi, come l'uso di convenzioni sintattiche comuni, una semantica condivisa per l'interpretazione, la possibilità di usare nello stesso contesto diverse tipologie di identificatori con meccanismi di accesso diversi, e la facilità nell'introduzione di nuovi tipi di identificatori.
            
            \vspace{3mm}
            
            Per sintetizzare, un identificatore è un frammento di informazione che fa riferimento ad un'entità, definita risorsa, dotata di identità. Nel caso degli URI, gli identificatori sono stringhe con una sintassi dcefinita che dipesa dallo schema, e che può essere espressa come
            
            \begin{center}
            \(<scheme>:<scheme-specific-part>\)
            \(<scheme>://<authority><path>?<query>\)
            \end{center}
            
            \(<scheme>\) non può essere omessa, mentre le altre parti sì. La seconda forma permette di rappresentare relazioni gerarchiche in un dominio di nomi. La componente <scheme-specific-part> non rispetta una semantica fissa per tutti gli URI.
            
            \vspace{3mm}
            
            L'URI si può specializzare in \textbf{URN} e \textbf{URL}.
        
        \subsubsection{URN}
        
            L'\textbf{Uniform Resource Name} (URN) identifica una risorsa per mezzo di un nome che dev'essere globalmente unico, e deve restare valido anche se la risorsa cessa di esistere o essere disponibile. 
            Un URN identifica una risorsa mediante un nome in un particolare dominio di nomi detto namespace. Dev'essere unico e duraturo, e deve consentire di interfacciarsi con la rsorsa a prescindere dalla sua ubicazione e alle modalità di accesso previste. 
            
            \vspace{3mm}
            
            Di conseguenza, l'URN permette di identificare una risorsa tramite una denominazione, ma non ci permette di accedervi, né spiega come farlo. Ad esempio, un URN potrebbe essere il nome e cognome di una persona, o il suo codice fiscale, o ancora l'ISBN di un libro.
            
        \subsubsection{URL}
            
            L'\textbf{Uniform Resource Locator} (URL) identifica una risorsa per mezzo del suo meccanismo di accesso primario (es. locazione nella rete) piuttosto che sulla base del suo nome o dei suoi attributi.
            
            Ad esempio, un URL è un indirizzo di casa, un numero di telefono, o l'indirizzo di un sito web.
            
            \vspace{3mm}
            
            Un URL tiene conto delle modalità per accedere alla risorsa. Specifica il protocollo necessario per il trasferimento della risorsa, e tipicamente il nome dello schema corrisponde al protocollo utilizato. La parte rimanente del nome dipende dal protocollo. Nella sua forma più comune, cioè uno schema HTTP-like, la sintassi è la seguente.
            
            \begin{center}
                \(<protocol>://[<username>:<password>@]<host[:<port>]\ \ ..\)
                \([</path>?<query>][\#fragment]]\)
            \end{center}
            
            Questa forma vale per diversi protocolli, come HTTP, HTTPS, FTP, WAP e così via, ma non, ad esempio, per la posta elettronica.
            
            \begin{itemize}
                \item 
                \(<protocol>\): descrive il protocollo da utilizzare (es. HTTP)
                \item
                \(<username>:<password>@\): credenziali per l'autenticazione
                \item
                \(<host>\): indirizzo del server su cui risiede la risorsa; può essere un indirizzo IP logico o fisico
                \item
                \(<port>\): definisce la porta da utilizzare; se non viene indicata, di default è 80 per l'HTTP
                \item
                \(<path>\): percorso (pathname) che identifica la risorsa sul file system del server; se manca, si accede di default ad un index.html
                \item
                \(<query>\): una stringa di caratteri che consente di passare al server uno o più parametri
                \item
                \(<fragment>\): una stringa di caratteri che si riferisce ad una risorsa subordinata ad una primaria
            \end{itemize}
            
            Gli URL sono classificati come \textit{opachi} o \textit{gerarchici}. Un URL opaco non è soggetto ad operazioni di parsing, mentre un URL gerarchico è soggetto ad ulteriori operazioni di parsing (cioè dotato di query, fragments, ubicazione non nella root e così via). 
            
            \vspace{3mm}
            
            Sugli URL gerarchici si possono effettaure diverse operazioni, come la \textbf{normalizzazione} (che prevede di rimuovere i segmenti "." e ".." dal path), la \textbf{risoluzione} (processo che, a partire da un URL originaria, produce un URL risultante basandosi su una terza URL, detta URL di base) e \textbf{relativizzazione}, che è il processo inverso della risoluzione.
            
            \vspace{3mm}
            
            Esempio di risoluzione:
            
            \begin{itemize}
                \item URL originaria: docs/guide/collections/designfaq.html\#28
                \item Base URL: http://di.unisa.it/
                \item Risultato: http://di.unisa.it/docs/guide/collections/designfaq.html\#28
            \end{itemize}
    
    \subsection{HTTP}
    
        L'\textbf{HTTP} è l'acronomimo di \textit{HyperText Transfer Protocol}. E' il protocollo di livello applicativo nel TCP/IP utilizzato per trasferire le risorser Web da server a client. Gestisce sia le richieste (URL) inviate al server che le risposte inviate al client (pagine web). E' un protocollo \textbf{stateless} e \textbf{one-shot}, e cioè né client né server mantengono informazioni relative ai messaggi precedentemente scambiati.
        
        \vspace{3mm}
        
        Un \textbf{client} è definito come un programma applicativo che stabilisce una connessione al fine di inviare delle richieste.
        Un \textbf{server} è definito come un programma applicativo che accetta connessioni al fine di ricevere richieste ed inviare specifiche risposte con le risorse richieste.
        Infine, una connessione è definita come un circuito virtuale stabilito a livello di trasporto tra due applicazioni per fini di comunicazione.
        
        \vspace{3mm}
        
        \textbf{Client e server si trasmettono messaggi}, intesi come l’unità base di comunicazione HTTP, che è definita come una specifica sequenza di byte concettualmente atomica.
        
        \vspace{3mm}
        
        I client web, come i browser, permettono all'utente di inviare una richiesta al server, e mostrano a schermo il risultato. Un flusso di richiesta (\textit{Request Stream}), in particolare, è formato da un metodo HTTP (che indica l'azione da eseguire), la pagina sulla quale effettuare l'azione (un URL) ed eventuali parametri.
        
        \vspace{3mm}
        
        Il flusso di risposta (\textit{Response Stream}) consiste in un \textit{header}, contenente uno status code (che determina il successo o meno dell'operazione), il tipo di contenuto previsto in formato MIME (text/plain, text/html, image/jpeg, image/gif, etc) e informazioni sul metodo usato (GET, POST, etc), e in un \textit{body}, in cui giace il contenuto in sé (HTML, immagini, etc).
        
        \vspace{3mm}
        
        \textbf{Si noti che è il server a rimanere in ascolto passivamente per eventuali connessioni TCP.} Infatti, è il client ad aprire una connessione TCP col server, che può accettare o meno. Il client, poi, invia una richiesta che viene eseguita o meno dal server.
        
        \vspace{3mm}
        
        La grande differenza fra HTTP 1.0 e 1.1 è la capacità di una singola connessione di essere utilizzata per più richieste. A differenza della prima versione, le connessioni \textbf{HTTP 1.1} sono persistenti. Il server lascia aperta la connessione TCP dopo aver spedito la risposta e può quindi ricevere le richieste sucessive sulla stessa coinnessione. Il server chiude, poi, la connessione quando viene specificato nell'header del messaggio. 
        
        \vspace{3mm}
        
        Per migliorare ulteriormente le prestazioni si può usare usa la tecnica del \textbf{pipelining}. Il pipelining consiste nell’invio di molteplici richieste da parte del client prima di terminare la ricezione delle risposte. Le risposte debbono però essere date nello stesso ordine delle richieste, poiché non è specificato un metodo esplicito di associazione tra richiesta e risposta.
        
        \vspace{3mm}
        
        La versione 2.0 di HTTP si occupa per lo più di ridurre la latenza per migliorare la velocità di caricamento delle pagine.
        
        \subsubsection{HTTP Methods}
            
            Prima abbiamo accennato al fatto che nella Request Stream viene specificato il metodo HTTP, il quale determina la tipologia della richiesta in sé e come dovrebbe essere formattato il messaggio di risposta. I metodi HTTP sono molti, ma i più importanti sono GET e POST.
            
            \vspace{3mm}
            
            Il metodo GET serve per richiedere una risorsa ad un server. ! È il metodo più frequente: è quello che viene attivato
            facendo click su un link ipertestuale di un documento HTML, o specificando un URL nell’apposito campo di un browser. È previsto il passaggio di parametri (la parte \(<query>\) dell’URL), a patto che non ecceda la lunghezza massima dell'URL.
            
            \vspace{3mm}
            
            Il metodo POST permette  di richiedere qualcosa e allo stesso tempo inviare dei dati al server, i quali non vengono esplicitati nella query dell'URL, nascondendoli invece nel body della Request Stream. Qui, non ci sono limiti di lunghezza nei parametri.
            
            \vspace{3mm}
            
            Ulteriori metodi HTTP sono PUT (memorizza o sostituisce una risorsa all'URL specificato), DELETE (cancella una risorsew all'URL specificato), HEAD (è una GET che non prevede un body nella risposta; è in genere usata per verificare un URL), OPTIONS (richiede informazioni sulle opzioni disponibili per la comunicazione), TRACE (consente al client di vedere cosa è stato ricevuto dal server per debugging).
        
        \subsubsection{HTTP Status Codes}
        
            Lo Status Code contenuto nell'header di una Response Stream è un numero di tre cifre. La prima cifra indica la classe della risposta, e le altre due ne determinano il tipo.
            
            \begin{itemize}
                \item \textbf{1xx - Informational} (la richiesta è in stato di valutazione dal server; deprecato da HTTP 1.0)
                \item \textbf{2xx - Successful} (il server ha ricevuto, compreso e accettato la richiesta)
                \item \textbf{3xx - Redirection} (il server ha ricevuto e compreso la richiesta, ma è necessario che il client effettui altre operazioni prima che riceva una risposta dal server)
                \item \textbf{4xx - Client Error} (errore sintattico, richiesta non autorizzata)
                \item \textbf{5xx - Server Error} (il server non è in grado di soddisfare la richiesta)
            \end{itemize}
        
        \subsubsection{HTTP Cookies}
        
            Parallelamente alle sequenze request/response, il protocollo prevede una struttura dati che si muove come un token, dal client al server e viceversa: i cookie. I cookie possono essere generati sia dal client che dal server. 
            
            Dopo la loro creazione vengono sempre passati ad ogni trasmissione di request e response. Hanno come scopo quello di fornire un supporto per il mantenimento di stato in un protocollo come HTTP che è essenzialmente stateless. 
            
            I cookie sono collezioni di stringhe e si strutturano come segue.
            
            \begin{itemize}
                \item
                \textbf{Key:} identifica univocamente un cookie all’interno di un \textit{domain:path}.
                
                \item
                \textbf{Value:} valore associato al cookie (è una stringa di max 255 caratteri).
                
                \item
                \textbf{Path:} posizione nell’albero di un sito al quale è associato (di default \(/\)).
                
                \item
                \textbf{Domain:} dominio dove è stato generato.
                
                \item
                \textbf{Max-age:} \textit{(opzionale)} numero di secondi di vita.
                
                \item
                \textbf{Secure:} \textit{(opzionale)} non molto usato. Questi cookie vengono trasferiti se e soltanto se il protocollo è sicuro (\textit{HTTPS}).
            
                \item
                \textbf{Version:} identifica la versione del protocollo di gestione dei cookie.
                
            \end{itemize}
            
            \vspace{3mm}
            
            I cookies usano due header, uno per la risposta, ed uno per richieste successive. 
            
            \begin{itemize}
                \item
                \textbf{Set-Cookie}, header della risposta: il client può memorizzarlo e rispedirlo alla prossima richiesta.
                
                \item
                \textbf{Cookie,} header della richiesta: il client decide
                se spedirlo sulla base del nome del documento, dell’indirizzo IP del server, e dell’età del cookie.
            \end{itemize}
        
        \subsubsection{HTTP Auth}
        
            Esistono situazioni in cui si vuole restringere l’accesso alle risorse ai soli utenti abilitati. Alcune tecniche utilizzate sono l'implementazione di filtri sulla base degli indirizzi IP; l'HTTP Basic; l'HTTP Digest; l'utilizzo di form per la richiesta di username e password.
            
            \vspace{3mm}
            
            La prima soluzione presenta chiari svantaggi: non funzionerebbe se l'indirizzo fosse pubblico, assegnato dinamicamente o fasullo. La seconda soluzione è obsoleta. Generalmente, si procede con la terza e più comunemnte con la quarta soluzione utilizzando il metodo POST.
            
            \vspace{3mm}
            
            E' importante assicurare la massima sicurezza dei dati trasmessi (si pensi alle password). Si punta alla confidenzialità, all'integrità, all'autenticità e al non ripudio (confermare mittente e destinatario dei dati) delle informazioni sensibili trasmesse. In genere, la sicurezza dell'autenticazione (e non solo) viene implementata tramite dei canali di trasporto ad hoc, come l'SSL o il TLS, che è alla base dell'HTTPS, un protocollo più sicuro e sostitutivo dell'HTTP, che aggiunge un livello che si occupa della gestione della sicurezza nella comunicazione dei messaggi fra richieste e risposte. E' basato sulla crittografia a chiave pubblica e sui certificati per autenticare il server.
            
            \vspace{3mm}
            
            In particolare, il protocollo SSL assicura la confidenzialità, l'autenticità e l'integrità della comunicazione fra HTTP e TCP. Si accede gli applicativi tramite HTTPS ed è basata sulla crittografia a chiave pubblica. In sintesi, si prende il dato, lo si cripta con una chiave pubblica, e l'unico che può decriptarla è il possessore della chiave privata.
        
        \subsubsection{HTTP Cache}
        
            Lo \textbf{User Agent} (tipicamente il browser) mantiene una cache delle pagine visitate dall’utente. L’uso delle user agent cache era molto importante in passato
            quando gli utenti non avevano accesso a connessioni di rete a banda larga. Questo modello di caching è ora molto rilevante per i dispositivi mobili al fine di consentire agli utenti di lavorare
            con connettività intermittente.
            
            \vspace{3mm}
            
            L'HTTP definisce vari meccanismi per la gestione delle cache.
            
            \begin{itemize}
                \item 
                \textbf{Freshness:} controllata lato server da un \textit{Expires Response
                Header} e lato cliente da una direttiva Cache-Control chiamata \textit{Max Age}.
                
                \item
                \textbf{Validation:} può essere usato per controllare se un elemento in cache è ancora corretto, ad esesempio nel caso in cui sia in cache da molto tempo.
                
                \item
                \textbf{Invalidation:} è normalmente un effetto collaterale di altre
                request che hanno attraversato la cache. Se per esempio viene mandata una POST, una PUT o una DELETE a un URL, il contenuto della cache deve essere e viene automaticamente invalidato.
            \end{itemize}